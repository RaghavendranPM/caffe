// Copyright 2014 BVLC and contributors.

#include <cstring>
#include <vector>

#include "cuda_runtime.h"
#include "gtest/gtest.h"
#include "caffe/blob.hpp"
#include "caffe/common.hpp"
#include "caffe/filler.hpp"
#include "caffe/vision_layers.hpp"
#include "caffe/test/test_gradient_check_util.hpp"

#include "caffe/test/test_caffe_main.hpp"

namespace caffe {

template <typename Dtype>
class SPPDetectorLayerTest : public ::testing::Test {
 protected:
  SPPDetectorLayerTest()
      : blob_bottom_data_(new Blob<Dtype>()),
        blob_bottom_conv5_windows_(new Blob<Dtype>()),
        blob_bottom_conv5_scales_(new Blob<Dtype>()),
        blob_top_(new Blob<Dtype>()) {}
  virtual void SetUp() {
    blob_bottom_vec_.push_back(blob_bottom_data_);
    blob_bottom_vec_.push_back(blob_bottom_conv5_windows_);
    blob_bottom_vec_.push_back(blob_bottom_conv5_scales_);
    blob_top_vec_.push_back(blob_top_);
  }
  virtual ~SPPDetectorLayerTest() {
    delete blob_bottom_data_;
    delete blob_bottom_conv5_windows_;
    delete blob_bottom_conv5_scales_;
    delete blob_top_;
  }
  Blob<Dtype>* const blob_bottom_data_;
  Blob<Dtype>* const blob_bottom_conv5_windows_;
  Blob<Dtype>* const blob_bottom_conv5_scales_;
  Blob<Dtype>* const blob_top_;
  vector<Blob<Dtype>*> blob_bottom_vec_;
  vector<Blob<Dtype>*> blob_top_vec_;

  void TestForward() {
    const int width = 6;
    const int height = 6;
    const int channels = 3;
    const int scale_num = 5;
    const int proposal_num = 10;
    blob_bottom_data_->Reshape(scale_num, channels, height, width);
    blob_bottom_conv5_windows_->Reshape(1, 1, proposal_num, 4);
    blob_bottom_conv5_scales_->Reshape(1, 1, 1, proposal_num);

    // Input: 5x 1 channels of:
    // [35     1     6    26    19    24]
    // [ 3    32     7    21    23    25]
    // [31     9     2    22    27    20]
    // [ 8    28    33    17    10    15] + 10 * c * eye(6) + 100 * s * eye(6)
    // [30     5    34    12    14    16]
    // [ 4    36    29    13    18    11]
    // (this is generated by magic(6) in MATLAB)
    for (int s = 0; s < scale_num; s++) {
      for (int c = 0; c < channels; c++) {
        int i = (s * channels + c) * height * width;
        blob_bottom_data_->mutable_cpu_data()[i +  0] = c * 10 + s * 100 + 35;
        blob_bottom_data_->mutable_cpu_data()[i +  1] = c * 10 + s * 100 + 1;
        blob_bottom_data_->mutable_cpu_data()[i +  2] = c * 10 + s * 100 + 6;
        blob_bottom_data_->mutable_cpu_data()[i +  3] = c * 10 + s * 100 + 26;
        blob_bottom_data_->mutable_cpu_data()[i +  4] = c * 10 + s * 100 + 19;
        blob_bottom_data_->mutable_cpu_data()[i +  5] = c * 10 + s * 100 + 24;
        blob_bottom_data_->mutable_cpu_data()[i +  6] = c * 10 + s * 100 + 3;
        blob_bottom_data_->mutable_cpu_data()[i +  7] = c * 10 + s * 100 + 32;
        blob_bottom_data_->mutable_cpu_data()[i +  8] = c * 10 + s * 100 + 7;
        blob_bottom_data_->mutable_cpu_data()[i +  9] = c * 10 + s * 100 + 21;
        blob_bottom_data_->mutable_cpu_data()[i + 10] = c * 10 + s * 100 + 23;
        blob_bottom_data_->mutable_cpu_data()[i + 11] = c * 10 + s * 100 + 25;
        blob_bottom_data_->mutable_cpu_data()[i + 12] = c * 10 + s * 100 + 31;
        blob_bottom_data_->mutable_cpu_data()[i + 13] = c * 10 + s * 100 + 9;
        blob_bottom_data_->mutable_cpu_data()[i + 14] = c * 10 + s * 100 + 2;
        blob_bottom_data_->mutable_cpu_data()[i + 15] = c * 10 + s * 100 + 22;
        blob_bottom_data_->mutable_cpu_data()[i + 16] = c * 10 + s * 100 + 27;
        blob_bottom_data_->mutable_cpu_data()[i + 17] = c * 10 + s * 100 + 20;
        blob_bottom_data_->mutable_cpu_data()[i + 18] = c * 10 + s * 100 + 8;
        blob_bottom_data_->mutable_cpu_data()[i + 19] = c * 10 + s * 100 + 28;
        blob_bottom_data_->mutable_cpu_data()[i + 20] = c * 10 + s * 100 + 33;
        blob_bottom_data_->mutable_cpu_data()[i + 21] = c * 10 + s * 100 + 17;
        blob_bottom_data_->mutable_cpu_data()[i + 22] = c * 10 + s * 100 + 10;
        blob_bottom_data_->mutable_cpu_data()[i + 23] = c * 10 + s * 100 + 15;
        blob_bottom_data_->mutable_cpu_data()[i + 24] = c * 10 + s * 100 + 30;
        blob_bottom_data_->mutable_cpu_data()[i + 25] = c * 10 + s * 100 + 5;
        blob_bottom_data_->mutable_cpu_data()[i + 26] = c * 10 + s * 100 + 34;
        blob_bottom_data_->mutable_cpu_data()[i + 27] = c * 10 + s * 100 + 12;
        blob_bottom_data_->mutable_cpu_data()[i + 28] = c * 10 + s * 100 + 14;
        blob_bottom_data_->mutable_cpu_data()[i + 29] = c * 10 + s * 100 + 16;
        blob_bottom_data_->mutable_cpu_data()[i + 30] = c * 10 + s * 100 + 4;
        blob_bottom_data_->mutable_cpu_data()[i + 31] = c * 10 + s * 100 + 36;
        blob_bottom_data_->mutable_cpu_data()[i + 32] = c * 10 + s * 100 + 29;
        blob_bottom_data_->mutable_cpu_data()[i + 33] = c * 10 + s * 100 + 13;
        blob_bottom_data_->mutable_cpu_data()[i + 34] = c * 10 + s * 100 + 18;
        blob_bottom_data_->mutable_cpu_data()[i + 35] = c * 10 + s * 100 + 11;
      }
    }
    // 3 valid windows, and the rest are zeros
    Dtype conv5_windows[40] = {0, 1, 6, 4, 3, 0, 6, 5, 2, 4, 3, 6};
    for (int i = 0; i < 40; i++) {
      blob_bottom_conv5_windows_->mutable_cpu_data()[i] = conv5_windows[i];
    }
    // 3 valid scales, and the rest are zeros
    Dtype conv5_scales[10] = {0, 4, 2};
    for (int i = 0; i < 10; i++) {
      blob_bottom_conv5_scales_->mutable_cpu_data()[i] = conv5_scales[i];
    }

    LayerParameter layer_param;
    SpatialPyramidPoolingParameter* spatial_pyramid_pooling_param =
        layer_param.mutable_spatial_pyramid_pooling_param();
    spatial_pyramid_pooling_param->set_pool(
        SpatialPyramidPoolingParameter_PoolMethod_MAX);
    spatial_pyramid_pooling_param->add_spatial_bin(3);
    spatial_pyramid_pooling_param->add_spatial_bin(2);
    SPPDetectorLayer<Dtype> layer(layer_param);
    layer.SetUp(blob_bottom_vec_, &blob_top_vec_);
    EXPECT_EQ(blob_top_->num(), proposal_num);
    EXPECT_EQ(blob_top_->channels(), channels*(3*3+2*2));
    EXPECT_EQ(blob_top_->height(), 1);
    EXPECT_EQ(blob_top_->width(), 1);
    layer.Forward(blob_bottom_vec_, &blob_top_vec_);

    // Expected output 10 * 1 * 1 * (3*3+2*2)
    // [ 32    7   26   28   33   22   36   34   13   32   26   36   34 ]
    // [ 28   33   17   30   34   14   36   36   18   34   34   36   34 ]
    // [ 27   27   20   27   27   20   27   27   20   27   20   27   20 ]
    // [                     row 3 to 9 are invalid                     ]
    int results[3][13] = {
        {32,  7, 26, 28, 33, 22, 36, 34, 13, 32, 26, 36, 34}, 
        {28, 33, 17, 30, 34, 14, 36, 36, 18, 34, 34, 36, 34},
        {27, 27, 20, 27, 27, 20, 27, 27, 20, 27, 20, 27, 20}};
    for (int n = 0; n < 2; n++) {     
      for (int c = 0; c < channels; c++) {
        for (int i = 0; i < 9; i++) {
          int offset = (c * 9+i) + n * channels * 13;
          Dtype actual = blob_top_->cpu_data()[offset];
          Dtype expect = results[n][i] + 10 * c + 100 * conv5_scales[n];
          CHECK_EQ(actual, expect) << "window " << n << " channel " << c
              << " index " << i << " mismatch";
        }
      }
      for (int c = 0; c < channels; c++) {
        for (int i = 0; i < 4; i++) {
          int offset = channels * 9 + (c * 4+i) + n * channels * 13;
          Dtype actual = blob_top_->cpu_data()[offset];
          Dtype expect = results[n][i+9] + 10 * c + 100 * conv5_scales[n];
          CHECK_EQ(actual, expect) << "window " << n << " channel " << c
              << " index " << i << " mismatch";
        }
      }
    }
  }
};

typedef ::testing::Types<float, double> Dtypes;
TYPED_TEST_CASE(SPPDetectorLayerTest, Dtypes);

TYPED_TEST(SPPDetectorLayerTest, TestCPUForward) {
  Caffe::set_mode(Caffe::CPU);
  this->TestForward();
}

TYPED_TEST(SPPDetectorLayerTest, TestGPUForward) {
  Caffe::set_mode(Caffe::GPU);
  this->TestForward();
}

}  // namespace caffe
